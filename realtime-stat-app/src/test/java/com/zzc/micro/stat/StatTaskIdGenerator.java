package com.zzc.micro.stat;

import com.squareup.javapoet.*;
import com.zzc.micro.stat.core.config.metadata.MeasureMetadata;
import com.zzc.micro.stat.core.config.metadata.MeasureMetadataManager;
import org.apache.commons.lang3.RegExUtils;
import org.apache.commons.lang3.Validate;

import javax.lang.model.element.Modifier;
import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.regex.Matcher;

/**
 * @author Administrator
 */
public class StatTaskIdGenerator {

    public static void main(String[] args) throws IOException {
        final String packageName = "com.zzc.micro.stat";
        final String className = "StatTaskIds";
        final String measureFileRegex = "classpath:measures/*.json";

        final File workDir = new File(new File("").getCanonicalPath());

        final File moduleDir = new File(workDir, "realtime-stat-api");
        Validate.isTrue(Files.exists(moduleDir.toPath()), "工作目录不存在，无法生成代码，请手工确认");
        Validate.isTrue(Files.isDirectory(moduleDir.toPath()), "工作目录不正确，无法生成代码，请手工确认");

        final File javaDir = new File(moduleDir, String.join(File.separator, "src", "main", "java"));
        final File outFile = new File(javaDir, RegExUtils.replaceAll(packageName, "\\.", Matcher.quoteReplacement(File.separator)) + Matcher.quoteReplacement(File.separator) + className + ".java");


        final List<MeasureMetadata> measures = new MeasureMetadataManager(measureFileRegex).getMeasures();
        System.out.println("共计" + measures.size() + "个指标任务");

        final TypeSpec.Builder builder = TypeSpec.enumBuilder(className)
                                                 .addJavadoc("Auto generated by " + StatTaskIdGenerator.class.getSimpleName())
                                                 .addAnnotation(AnnotationSpec.builder(SuppressWarnings.class).addMember("value", "$S", "unused").build())
                                                 .addModifiers(Modifier.PUBLIC)
                                                 .addMethod(MethodSpec.constructorBuilder()
                                                                      .addParameter(String.class, "keys")
                                                                      .addParameter(String.class, "desc")
                                                                      .addStatement("this.$N = $N", "keys", "keys")
                                                                      .addStatement("this.$N = $N", "desc", "desc")
                                                                      .build())
                                                 .addField(FieldSpec.builder(String.class, "keys", Modifier.PRIVATE, Modifier.FINAL)
                                                                    // @formatter:off
                                                                    .addJavadoc(
                                "使用时参考key值。\n" +
                                "支持多级嵌套结构，如: \n" +
                                "appId --> marketId ==> 销售额\n" +
                                "此处配置为: [appId,marketId]\n" +
                                "<p>\n" +
                                "底层存储将直接平铺成map ==>\n" +
                                "mapName: 任务ID|周期|appId\n" +
                                "key: marketId\n" +
                                "value: 销售额\n" +
                                "<p>\n" +
                                "性能等因素综合考虑，目前限制：\n" +
                                "1、配置上目前尽量仅配置成最多2级结构（appId为第1级，marketId为第2级）；\n" +
                                "2、多级结构时，必须keys必须全传或仅允许少传最后一个key。\n" +
                                "如上述例子：可以传 appId（返回这个appId下所有市场的销售额）；也可以传 appId,market（返回找个appId指定的单个市场marketId的销售额）。\n" +
                                "如果后续有需要支持不传appId查询的，需要底层数据存储(目前为redis数据，lua脚本操作)调整为支持多级嵌套map结构【目前没有这方面的需求，暂不做支持】。")
                                                                    // @formatter:on
                                                                    .build())
                                                 .addField(FieldSpec.builder(String.class, "desc", Modifier.PRIVATE, Modifier.FINAL).addJavadoc("指标任务描述").build())
                                                 .addMethod(MethodSpec.methodBuilder("getKeys").returns(String.class).addModifiers(Modifier.PUBLIC).addStatement("return this.keys").build())
                                                 .addMethod(MethodSpec.methodBuilder("getDesc").returns(String.class).addModifiers(Modifier.PUBLIC).addStatement("return this.desc").build())
                                                 .addMethod(MethodSpec.methodBuilder("of")
                        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                        .addParameter(String.class, "code", Modifier.FINAL)
                        .returns(ClassName.get(packageName, className))
                        // @formatter:off
                        .addCode("if (null == code || code.trim().length() == 0) {\n"
                                + "    return null;\n"
                                + "}\n"
                                + "for (" + className + " value : values()) {\n"
                                + "    if (value.name().equals(code)) {\n"
                                + "        return value;\n"
                                + "    }\n"
                                + "}\n"
                                + "return null;")
                        // @formatter:on
                        .build());

        measures.forEach(measure -> builder.addEnumConstant(measure.getCode(),
                TypeSpec.anonymousClassBuilder("$S, $S", measure.getKeys(), measure.getDesc()).build()));

        final JavaFile javaFile = JavaFile.builder(packageName, builder.build()).indent("    ").skipJavaLangImports(true).build();

        final Path path = outFile.toPath();
        Files.deleteIfExists(path);
        Files.createFile(path);
        final BufferedWriter writer = Files.newBufferedWriter(path, StandardCharsets.UTF_8);
        javaFile.writeTo(writer);
        writer.flush();
        writer.close();
    }
}
